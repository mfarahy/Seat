<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@import namespace="System.Data.Entity.Design.PluralizationServices" #>
<#@
 output extension=".cs"#><#
    // version 5

    CodeGenerationTools code = new CodeGenerationTools(this);
    MetadataLoader loader = new MetadataLoader(this);
    CodeRegion region = new CodeRegion(this, 1);
    MetadataTools ef = new MetadataTools(this);
     
    string inputFile = @"..\Dal\SeatDataModel.edmx";
	string service_factory_object_name="MMP-ServiceFactory";
    MetadataWorkspace metadataWorkspace = null;
    bool allMetadataLoaded =loader.TryLoadAllMetadata(inputFile, out metadataWorkspace);
    EdmItemCollection ItemCollection = (EdmItemCollection)metadataWorkspace.GetItemCollection(DataSpace.CSpace);
    OriginalValueMembers originalValueMembers = new OriginalValueMembers(allMetadataLoaded, metadataWorkspace, ef);
    string namespaceName = code.VsNamespaceSuggestion();

    EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

// Write out support code to primary template output file
WriteHeader(fileManager);
BeginNamespace(namespaceName, code);
WriteCustomObservableCollection();
WriteINotifyComplexPropertyChanging();
WriteEqualityComparer();
EndNamespace(namespaceName);

    // Emit Entity Types
    foreach (EntityType entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
    {
	var impMethod = entity.BaseType==null?"virtual":"override";
	List<string> subInterfaces=new List<string>();

		if(entity.Properties
	.Any(p => p.TypeUsage.EdmType is PrimitiveType &&
	p.Name=="DeleteDate"))
	subInterfaces.Add("IDeleteLogger");
	
	int protoMemberIndex=1;

	if(entity.BaseType!=null)
		subInterfaces.Add("I"+entity.BaseType.Name);
		
        fileManager.StartNewFile(entity.Name + ".cs");
        BeginNamespace(namespaceName, code);#>
        <#=Accessibility.ForType(entity)#> interface I<#=code.Escape(entity)#><#
		if(subInterfaces.Count>0)
		{
		#>:<#=String.Join(",",subInterfaces.ToArray())  #>
		<#
		}
		#>
{

<#
        foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entity))
        {
		if(Accessibility.ForProperty(edmProperty)!="public")continue;
#>
 <#=                code.Escape(edmProperty.TypeUsage)#> <#=code.Escape(edmProperty)#>{
 <# if(Accessibility.ForGetter(edmProperty)==""){ #>
 get;
 <# }
 if(Accessibility.ForSetter(edmProperty)==""){
  #>
 set;
 <# } #>
 }

<#        
        } 
        foreach(EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entity))
        {
#>
 <#=                code.Escape(edmProperty.TypeUsage)#> <#=                code.Escape(edmProperty)#>{get;set;}
<#        } 
        foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(np => np.DeclaringType == entity))
        {
            if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many){
#>
    TrackableCollection<<#=code.Escape(navProperty.ToEndMember.GetEntityType())#>> <#=code.Escape(navProperty)#>{get;set;}
<#            }else{ #>
<#=code.Escape(navProperty.ToEndMember.GetEntityType())#> <#=code.Escape(navProperty)#>{get;set;}
<#            }
} #>
}// interface

<#
            bool first=true,closeComment=false;
            foreach(var child_nav in entity.NavigationProperties){
                if(child_nav.ToEndMember.GetEntityType()==entity && 
                    child_nav.FromEndMember.GetEntityType()==entity &&
                    child_nav.ToEndMember.RelationshipMultiplicity== RelationshipMultiplicity.Many &&
                    child_nav.FromEndMember.RelationshipMultiplicity== RelationshipMultiplicity.ZeroOrOne )
                {  
                    var association = metadataWorkspace
                        .GetItems<AssociationType>(DataSpace.CSpace)
                        .Single(a => a.Name == child_nav.RelationshipType.Name);

                    // Then look at the referential constraints
                    var toColumns = String.Join(",", 
                        association.ReferentialConstraints.SelectMany(rc => rc.ToProperties));
                         var fromColumns = String.Join(",", 
                        association.ReferentialConstraints.SelectMany(rc => rc.FromProperties));
             
                    var parent_nav=entity.NavigationProperties.Where(np=>np.GetDependentProperties().Any(x=>x.Name==toColumns)).First();
                    var simple_string=entity.Properties
                        .Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entity &&
                        !ef.IsKey(p) && p.TypeUsage.ToString()=="Edm.String").FirstOrDefault();
                    if(simple_string==null) continue;
            #>
[Tree("<#=fromColumns #>","<#=toColumns #>","<#=child_nav.Name#>")]

<#                  
                    if(!first){
                        closeComment=true;
                        #> /* <#
                    }
break;
                }
            }
            if(closeComment){
 #>
*/
<#}#>
<# PluralizationService pluralizer = PluralizationService.CreateService(System.Globalization.CultureInfo.CurrentCulture); #>
[Table("<#=pluralizer.Pluralize(code.Escape(entity))#>")]

[Serializer(typeof(ProtobufSerializer))]

[ProtoContract]

<# if (entity.BaseType != null){#>
 [ProtoInclude(<#=protoMemberIndex++#>,typeof(<#=code.Escape(entity.BaseType)#>))]

<#}else{#>
[Exir.Framework.Common.Caching.CacheableKey(<#
	List<string> cacheKeys=new List<String>();
	foreach (var  property in entity.Properties)
	{
		if(ef.IsKey(property) || (property.MetadataProperties!=null && property.MetadataProperties.Any(y=>y.Name=="http://schemas.microsoft.com/ado/2009/02/edm/annotation:StoreGeneratedPattern")
			 && property.TypeUsage.Facets!=null && property.TypeUsage.Facets.Any(y=>y.Name=="FixedLength" && (bool)y.Value)
			 && property.TypeUsage.Facets.Any(y=>y.Name=="MaxLength" && (int)y.Value==8)))
		{cacheKeys.Add("nameof("+property+")");}
	}
	#> new string[]{<#= String.Join(", ",cacheKeys) #>} <#
#>)]

<#}#>
[Entity]

<# WriteEntityTypeSerializationInfo(entity, ItemCollection, code, ef); #>
<#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.AbstractOption(entity))#>partial class <#=code.Escape(entity)#><#=                code.StringBefore(" : ", code.Escape(entity.BaseType))#><#=                entity.BaseType == null ? ":IEntityBase, " : ", "#>I<#=                code.Escape(entity)#>,IObjectWithChangeTracker, INotifyPropertyChanged, ICloneable
{
<#
    region.Begin("Primitive Properties");
	
    foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == entity))
    {
#>
<#
if(ef.IsKey(edmProperty))
{
#>
[Key]

<#
}
#>
<#
string size="0";
if(edmProperty.TypeUsage!=null && edmProperty.TypeUsage.EdmType.Name=="String" && 
edmProperty.TypeUsage.Facets.Contains("MaxLength") && edmProperty.TypeUsage.Facets["MaxLength"].Value!=null){
		size= edmProperty.TypeUsage.Facets["MaxLength"].Value.ToString();
		if(size=="Max"||String.IsNullOrEmpty(size))
		size="0";
		}
if(edmProperty.TypeUsage!=null && edmProperty.TypeUsage.EdmType.Name=="String" && size!="0")
    {
#>
[MaxLength(<#=size#>)]

<#
}
#>
<#if(!edmProperty.Nullable){#>
[Required]

<#}#>
<#if(edmProperty.Name.StartsWith("Audit_")){#>
[RestfullIgnore]

<#}#>
	[ProtoMember(<#=protoMemberIndex++#>)]

    [DataMember]

    <#=Accessibility.ForProperty(edmProperty)#> virtual <#=code.Escape(edmProperty.TypeUsage)#> <#=code.Escape(edmProperty)#>
    {
        <#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get { return <#=code.FieldName(edmProperty)#>; }
        <#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set
        {
<#
        if (edmProperty.TypeUsage.EdmType is PrimitiveType &&
		((PrimitiveType)edmProperty.TypeUsage.EdmType).PrimitiveTypeKind == PrimitiveTypeKind.Binary &&
            (ef.IsKey(edmProperty) || entity.NavigationProperties.Where(np=>np.GetDependentProperties().Contains(edmProperty)).Any()))
        {
#>
            if (!EqualityComparer.BinaryEquals(<#=code.FieldName(edmProperty)#>, value))
<#
        }
        else
        {
#>
            if (<#=code.FieldName(edmProperty)#> != value)
<#
        }
#>
            {
<#
        if (ef.IsKey(edmProperty))
        {
            string errorMessage = String.Format("The property '{0}' is part of the object's key and cannot be changed. Changes to key properties can only be made when the object is not being tracked or is in the Added state.", edmProperty.Name);
#>
                if (ChangeTracker.ChangeTrackingEnabled && ChangeTracker.State != ObjectState.Added && !Typing.IsEquals(<#=code.FieldName(edmProperty)#>,Typing.GetDefaultValue(typeof(<#=code.Escape(edmProperty.TypeUsage)#>))))
                {
                    throw new InvalidOperationException("<#=errorMessage#>");
                }
<#
        }
        else if (originalValueMembers.IsOriginalValueMember(edmProperty))
        {
#>
                ChangeTracker.RecordOriginalValue("<#=edmProperty.Name#>", <#=code.FieldName(edmProperty)#>);
<#
                }
        if(!ef.IsKey(edmProperty))
        {
                #>
                    if (!ChangeTracker.OriginalValues.ContainsKey("<#=edmProperty.Name#>"))
                        ChangeTracker.RecordOriginalValue("<#=edmProperty.Name#>", <#=code.FieldName(edmProperty)#>);
                        
<#
   }
                bool hasDependentProperties = entity.NavigationProperties.Where(np=>np.GetDependentProperties().Contains(edmProperty)).Any();
                if (hasDependentProperties)
                {
#>
                if (!IsDeserializing)
                {
<#
                }
                foreach (var np in entity.NavigationProperties.Where(np=>np.GetDependentProperties().Contains(edmProperty)))
                {
                    EdmProperty principalProperty = ef.GetCorrespondingPrincipalProperty(np, edmProperty);
                    if (principalProperty.TypeUsage.EdmType is PrimitiveType &&
					((PrimitiveType)principalProperty.TypeUsage.EdmType).PrimitiveTypeKind == PrimitiveTypeKind.Binary)
                    {
#>
                    if (<#=                            code.Escape(np)#> != null && !EqualityComparer.BinaryEquals(<#=                            code.Escape(np)#>.<#=                            code.Escape(principalProperty)#>, value))
<#
                    }
                    else
                    {
#>
                    if (<#=                            code.Escape(np)#> != null && <#=                            code.Escape(np)#>.<#=                            code.Escape(principalProperty)#> != value)
<#
                    }
#>
                    {
<#
                    if (!(np.GetDependentProperties().Where(p=>ef.IsNullable(p)).Any() &&
                        np.GetDependentProperties().Count() > 1))
                    {
#>
                        <#=                            code.Escape(np)#> = null;
<#
                    }
                    else
                    {
#>
                        var previousValue = <#=                            code.FieldName(np)#>;
                        <#=                            code.FieldName(np)#> = null;
                        Fixup<#=                            np.Name#>(previousValue, skipKeys: true);
                        OnNavigationPropertyChanged("<#=                            np.Name#>");
<#
                    }
#>
                    }
<#
                }
                if (hasDependentProperties)
                {
#>
                }
<#
                }
#>
                <#=                    code.FieldName(edmProperty)#> = value;
                OnPropertyChanged("<#=                    edmProperty.Name#>");
            }
        }
    }
    protected <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#><#=code.StringBefore(" = ", code.CreateLiteral(edmProperty.DefaultValue))#>;
<#
            }
            region.End();

            region.Begin("Complex Properties");

            foreach(EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entity))
            {
#>

 	[ProtoMember(<#=protoMemberIndex++#>)]

   [DataMember]

    <#=                    Accessibility.ForProperty(edmProperty)#> virtual  <#=                    code.Escape(edmProperty.TypeUsage)#> <#=                    code.Escape(edmProperty)#>
    {
        <#=                    code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get
        {
            if (!<#=                    InitializedTrackingField(edmProperty, code)#> && <#=                    code.FieldName(edmProperty)#> == null)
            {
                <#=                    code.FieldName(edmProperty)#> = new <#=                    code.Escape(edmProperty.TypeUsage)#>();
                ((INotifyComplexPropertyChanging)<#=                    code.FieldName(edmProperty)#>).ComplexPropertyChanging += Handle<#=                    edmProperty.Name#>Changing;
            }
            <#=                    InitializedTrackingField(edmProperty, code)#> = true;
            return <#=                    code.FieldName(edmProperty)#>;
        }
        <#=                    code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set
        {
            <#=                    InitializedTrackingField(edmProperty, code)#> = true;
            if (!Equals(<#=                    code.FieldName(edmProperty)#>, value))
            {
                if (<#=                    code.FieldName(edmProperty)#> != null)
                {
                    ((INotifyComplexPropertyChanging)<#=                    code.FieldName(edmProperty)#>).ComplexPropertyChanging -= Handle<#=                    edmProperty.Name#>Changing;
                }

                Handle<#=                    edmProperty.Name#>Changing(this, null);
                <#=                    code.FieldName(edmProperty)#> = value;
                OnPropertyChanged("<#=                    edmProperty.Name#>");

                if (value != null)
                {
                    ((INotifyComplexPropertyChanging)<#=                    code.FieldName(edmProperty)#>).ComplexPropertyChanging += Handle<#=                    edmProperty.Name#>Changing;
                }
            }
        }
    }
    protected <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#>;
    private bool <#=InitializedTrackingField(edmProperty, code)#>;
<#
            }

            region.End();

            ////////
            //////// Write Navigation properties -------------------------------------------------------------------------------------------
            ////////

            region.Begin("Navigation Properties");

            foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(np => np.DeclaringType == entity))
            {
                NavigationProperty inverse = ef.Inverse(navProperty);
                if (inverse != null &&  !IsReadWriteAccessibleProperty(inverse))
                {
                    inverse = null;
                }
#>

 	[ProtoMember(<#=protoMemberIndex++#>,AsReference =true)]

<#
EdmProperty dpp=null;
			
			if(navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many||
			navProperty.FromEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many){
			dpp= ef.GetDependentProperties(navProperty).FirstOrDefault();
			}
if(navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many
&& dpp!=null)
{
#>
[ForeignKey("<#=dpp#>")]

<#}#>
   [DataMember]

<#
        if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
#>
    <#=Accessibility.ForReadOnlyProperty(navProperty)#>  virtual  TrackableCollection<<#=code.Escape(navProperty.ToEndMember.GetEntityType())#>> <#=code.Escape(navProperty)#>
    {
        get
        {
            if (<#=                        code.FieldName(navProperty)#> == null)
            {
                <#=                        code.FieldName(navProperty)#> = new TrackableCollection<<#=                        code.Escape(navProperty.ToEndMember.GetEntityType())#>>();
                <#=                        code.FieldName(navProperty)#>.CollectionChanged += Fixup<#=                        navProperty.Name#>;
            }
            return <#=                        code.FieldName(navProperty)#>;
        }
        set
        {
            if (!ReferenceEquals(<#=                        code.FieldName(navProperty)#>, value))
            {
              //  if (ChangeTracker.ChangeTrackingEnabled)
             //   {
             //       throw new InvalidOperationException("Cannot set the FixupChangeTrackingCollection when ChangeTracking is enabled");
             //   }
                if (<#=                        code.FieldName(navProperty)#> != null)
                {
                    <#=                        code.FieldName(navProperty)#>.CollectionChanged -= Fixup<#=                        navProperty.Name#>;
<#
                    if (ef.IsCascadeDeletePrincipal(navProperty))
                    {
#>
                    // This is the principal end in an association that performs cascade deletes.
                    // Remove the cascade delete event handler for any entities in the current collection.
                    foreach (<#=                            code.Escape(navProperty.ToEndMember.GetEntityType())#> item in <#=                            code.FieldName(navProperty)#>)
                    {
                        ChangeTracker.ObjectStateChanging -= item.HandleCascadeDelete;
                    }
<#
                    }
#>
                }
                <#=                        code.FieldName(navProperty)#> = value;
                if (<#=                        code.FieldName(navProperty)#> != null)
                {
                    <#=                        code.FieldName(navProperty)#>.CollectionChanged += Fixup<#=                        navProperty.Name#>;
<#
                    if (ef.IsCascadeDeletePrincipal(navProperty))
                    {
#>
                    // This is the principal end in an association that performs cascade deletes.
                    // Add the cascade delete event handler for any entities that are already in the new collection.
                    foreach (<#=                            code.Escape(navProperty.ToEndMember.GetEntityType())#> item in <#=                            code.FieldName(navProperty)#>)
                    {
                        ChangeTracker.ObjectStateChanging += item.HandleCascadeDelete;
                    }
<#
                    }
#>
                }
                OnNavigationPropertyChanged("<#=                        navProperty.Name#>");
            }
        }
    }
    protected TrackableCollection<<#=code.Escape(navProperty.ToEndMember.GetEntityType())#>> <#=code.FieldName(navProperty)#>;
<#
                }
                else
                {
#>
    <#=                        Accessibility.ForProperty(navProperty)#>  <#=                        code.Escape(navProperty.ToEndMember.GetEntityType())#> <#=                        code.Escape(navProperty)#>
    {
        <#=                        code.SpaceAfter(Accessibility.ForGetter(navProperty))#>get { return <#=                        code.FieldName(navProperty)#>; }
        <#=                        code.SpaceAfter(Accessibility.ForSetter(navProperty))#>set
        {
            if (!ReferenceEquals(<#=                        code.FieldName(navProperty)#>, value))
            {
<#
                    // If this is the dependent end of an identifying relationship, the principal end can only be changed if the dependent is in the Added state and the principal's key matches the foreign key on the dependent
                    if (ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.ToEndMember))
                    {
#>
                if (ChangeTracker.ChangeTrackingEnabled && ChangeTracker.State != ObjectState.Added && value != null)
                {
<#
                        List<EdmProperty> dependents = navProperty.GetDependentProperties().ToList();
                        int dependentCount = dependents.Count;
                        StringBuilder keyMatchCondition = new StringBuilder();
                        for (int i = 0; i < dependentCount; i++)
                        {
                            EdmProperty dependentProperty = dependents[i];
                            EdmProperty principalProperty = ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty);
                            string escapedDependent = code.Escape(dependentProperty);
                            string escapedPrincipal = code.Escape(principalProperty);

                            if (i > 0)
                            {
                                keyMatchCondition.AppendFormat(" || ");
                            }

                            string equality = null;
                            if (principalProperty.TypeUsage.EdmType is PrimitiveType &&
							((PrimitiveType)principalProperty.TypeUsage.EdmType).PrimitiveTypeKind == PrimitiveTypeKind.Binary)
                            {
                                equality = "!EqualityComparer.BinaryEquals({0}, value.{1})";
                            }
                            else
                            {
                                equality = "{0} != value.{1}";
                            }
                            keyMatchCondition.AppendFormat(CultureInfo.InvariantCulture, equality, escapedDependent, escapedPrincipal);
                        }
#>
                    // This the dependent end of an identifying relationship, so the principal end cannot be changed if it is already set,
                    // otherwise it can only be set to an entity with a primary key that is the same value as the dependent's foreign key.
                    if (<#=                            keyMatchCondition.ToString()#>)
                    {
                        throw new InvalidOperationException("The principal end of an identifying relationship can only be changed when the dependent end is in the Added state.");
                    }
                }
<#
                    }
#>
                var previousValue = <#=                        code.FieldName(navProperty)#>;
                <#=                        code.FieldName(navProperty)#> = value;
                Fixup<#=                        navProperty.Name#>(previousValue);
                OnNavigationPropertyChanged("<#=                        navProperty.Name#>");
            }
        }
    }
    protected <#=code.Escape(navProperty.ToEndMember.GetEntityType())#> <#=code.FieldName(navProperty)#>;
<#
                }
            }
            region.End();

		if(!entity.Abstract){	
        #>

		public <#=impMethod#> object Clone(){
			return Clone(new Dictionary<object,object>(),true);
		}

public   <#=impMethod#> object Clone(Dictionary<object,object> clonedObjects,bool includePrimaryKey)
{
    <#=                entity.Name #> cloned = new <#=                entity.Name #>();
            clonedObjects.Add(this, cloned);
    <#            foreach (var  property in entity.Properties)
            {
			if(ef.IsKey(property)){
			#>
				if(includePrimaryKey)
				<#  
			}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
#>
     cloned.<#=code.FieldName(property)#>=this.<#=code.FieldName(property)#>;
    <#            }
            foreach (var navp in entity.NavigationProperties)
            {
                if (navp.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
                {
#>	
if(<#=navp#>!=null){
    cloned.<#=navp#>=new TrackableCollection<<#=code.Escape(navp.ToEndMember.GetEntityType()) #>>();
    foreach(<#=code.Escape(navp.ToEndMember.GetEntityType()) #> item in <#=navp#>)
    if (!clonedObjects.ContainsKey(item))
    cloned.<#=navp#>.Add((<#=code.Escape(navp.ToEndMember.GetEntityType()) #>)item.Clone(clonedObjects,includePrimaryKey));
    else
    cloned.<#=navp#>.Add((<#=code.Escape(navp.ToEndMember.GetEntityType()) #>)clonedObjects[item]);
}
<#
                }
                else
                {
#>
if(<#=navp#>!=null) {
if (!clonedObjects.ContainsKey(<#=navp#>))
cloned.<#=navp#>=(<#=code.Escape(navp.ToEndMember.GetEntityType()) #>)<#=navp#>.Clone(clonedObjects,includePrimaryKey);
else
                cloned.<#=navp#> = (<#=code.Escape(navp.ToEndMember.GetEntityType()) #>)clonedObjects[<#=navp#>];
            }
<#
                }
            }
#>
    

    return cloned;
}
<#
}
#>


public virtual long ComputeHashCode()
	{
		var sb = new System.Text.StringBuilder();

		<# foreach (var  property in entity.Properties.Where(x=>x.Name!="Singnature")) { 
			if(property.Nullable)
			{ #>
				sb.Append(this.<#=code.FieldName(property)#>?.ToString());
			<#} else {#>
				sb.Append(this.<#=code.FieldName(property)#>.ToString());
		<# } #>
			// <#=property.Name#>
			sb.Append("`");

		<#} #>

		return sb.ToString().ToLower().FarmhashCode64();
}
        public <#=impMethod#> T CreateService<T>() 
		<#if(entity.BaseType==null){#>
		 where T : IService
		 <#}#>
        {
            if (ObjectRegistry.ContainsObject("<#=service_factory_object_name#>"))
            {
                var service_factory = (IServiceFactory)ObjectRegistry.GetObject("<#=service_factory_object_name#>",true);
                return (T)service_factory.CreateByModel<<#= entity.Name #>>();
            }
            else
               {
					return (T)StaticServiceFactory.CreateByModel<<#= entity.Name #>>();			   
				}
        }
	protected const int LAST_PROTOBUF_MEMBER_INDEX=<#=protoMemberIndex#>;

public <#=impMethod#> void ResetChanges(bool includeNavigations=false)
{
    if(!includeNavigations){
        ChangeTracker.ResetChanges();
        return;
    }

    ResetChanges(new List<object>(), includeNavigations);
}
public <#=impMethod#> void ResetChanges(List<object> reseted_objects, bool includeNavigations=false)
{
    if(reseted_objects.Contains(this)) return;

    ChangeTracker.ResetChanges();
     
    reseted_objects.Add(this);

   <# foreach (var navp in entity.NavigationProperties)
                {
                    if (navp.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
                    {
    #>	
    if(<#=code.FieldName(navp)#>!=null)
    foreach(var item in <#=code.FieldName(navp)#>) if(!reseted_objects.Contains(item)) item.ResetChanges(reseted_objects);
    <#
                    }
                    else
                    {
    #>
    if(<#=code.FieldName(navp)#>!=null && !reseted_objects.Contains(<#=code.FieldName(navp)#>)) <#=code.FieldName(navp)#>.ResetChanges(reseted_objects);
    <#
                    }
                }
    #>
}

public virtual bool Equals(IEntityBase obj)
    {
		bool result= this.Equals(obj, new List<object>());

	return result;
}   

public <#=impMethod#> bool Equals(object other,List<object> checked_objects)
{
	if(checked_objects.Contains(this)) return true;
	
	checked_objects.Add(this);

    <#=entity.Name #> casted_other = other as <#=entity.Name #>;

	if(casted_other==null) {
		checked_objects.Remove(this);
		return false;
	}

    <#foreach (var  property in entity.Properties)
            {
#>
     if(!Typing.IsEquals(this.<#=property#>,casted_other.<#=property#>))
{
		checked_objects.Remove(this);
		return false;
	}    <#            
	}
            foreach (var navp in entity.NavigationProperties)
            {
                if (navp.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
                {
#>	
if(this.<#=navp.Name#>.Count!= casted_other.<#=navp.Name#>.Count) {
		checked_objects.Remove(this);
		return false;
	}
List<int> <#=navp#>_compared=new List<int>(this.<#=navp#>.Count);
for(int i=0;i<this.<#=navp#>.Count;++i)
	if(this.<#=navp#>[i]!= null) {
		bool found=false;
		for(int j=0;j<this.<#=navp#>.Count;++j){
			if(<#=navp#>_compared.Contains(j)) continue;			
			if(this.<#=navp#>[i].Equals(casted_other.<#=navp#>[j],checked_objects)){
				<#=navp#>_compared.Add(j);
				found=true;
				break;
			}
		}
		if(!found){
		checked_objects.Remove(this);
		return false;
	}
	}
	else{
		for(int j=0;j<this.<#=navp#>.Count;++j){
			if(<#=navp#>_compared.Contains(j)) continue;
			if(casted_other.<#=navp#>[j]==null){
				<#=navp#>_compared.Add(j);
				break;
			}
		}
	}

if(<#=navp#>_compared.Distinct().Count()!=this.<#=navp#>.Count)
 {
		checked_objects.Remove(this);
		return false;
	}
<#
                }
                else
                {
#>
if(this.<#=navp#>!= null) {
if(!this.<#=navp#>.Equals(casted_other.<#=navp#>,checked_objects))
{
		checked_objects.Remove(this);
		return false;
	}}
else
if(casted_other.<#=navp#>!= null) 
{
		checked_objects.Remove(this);
		return false;
	}<#
                }
            }
#>

checked_objects.Remove(this);

return true;
}

<#

            region.Begin("Metadata section");
        #>
        [NotMapped]

        [ProtoIgnore]

        [Newtonsoft.Json.JsonIgnore]

        [Jil.JilDirective(Ignore =true)]

	    [System.Xml.Serialization.XmlIgnore]

        public <#=impMethod#> IEnumerable<IField> PrimaryKeys { get{ return GetPrimaryKeys(); } }

    public <#=impMethod#> IEnumerable<IField> GetFields ()
    {
            var array1 = GetPrimitiveFields();
            var array2 = GetNavigationFields();
            if(array1.Any() && array2.Any()) return array1.Union(array2);
            else if(array1.Any()) return array1;
            else if(array2.Any()) return array2;
            return null;
    }

    public <#=impMethod#> IEnumerable<IField> GetPrimaryKeys()
{
  <#            foreach (var  property in entity.Properties)
                {
                    if(ef.IsKey(property))
                    {
					var metaIdentity=property.MetadataProperties.Where(x=>x.Value.ToString().Equals("Identity") && x.Name.EndsWith("StoreGeneratedPattern")).FirstOrDefault();
					#>
    yield return new BaseField{Name= "<#=property #>", Kind = FieldKinds.Primitive,PropertyType =typeof(<#=code.Escape(property.TypeUsage)#>),
	IsIdentity=<#=(metaIdentity!=null).ToString().ToLower()#>
	 };
<#						                
						if(metaIdentity==null){#>
						// This is none identity primary key	
						<#}
					}
                }
    #>
}

public virtual Type GetFieldType(string propertyName)
{
    var field = GetFields().Where(x => x.Name == propertyName).FirstOrDefault();
    return field != null ? field.PropertyType: null;
}

public virtual bool HasField(string propertyName)
{
    var field = GetFields().Where(x => x.Name == propertyName).FirstOrDefault();
    return field != null;
}


    private static IEnumerable<IField> GetPrimitiveFields()
    {
    <#            foreach (EdmProperty  property in entity.Properties)
            {
			      bool? isIdentity=null;
			        if(ef.IsKey(property)){
					var metaIdentity=property.MetadataProperties.Where(x=>x.Value.ToString().Equals("Identity") && x.Name.EndsWith("StoreGeneratedPattern")).FirstOrDefault();
					if(metaIdentity!=null)
						isIdentity=true;
					else
						isIdentity=false;
					}

				            var isVersion= 
			property.MetadataProperties!=null && property.MetadataProperties.Any(y=>y.Name=="http://schemas.microsoft.com/ado/2009/02/edm/annotation:StoreGeneratedPattern")
			 && property.TypeUsage.Facets!=null && property.TypeUsage.Facets.Any(y=>y.Name=="FixedLength" && (bool)y.Value)
			 && property.TypeUsage.Facets.Any(y=>y.Name=="MaxLength" && (int)y.Value==8);

		string size="0";
		if(property.TypeUsage!=null && property.TypeUsage.EdmType.Name=="String" && 
property.TypeUsage.Facets.Contains("MaxLength") && property.TypeUsage.Facets["MaxLength"].Value!=null){
		size= property.TypeUsage.Facets["MaxLength"].Value.ToString();
		if(size=="Max"||String.IsNullOrEmpty(size))
		size="0";
		}
				#>
    yield return new BaseField{Name= "<#=
    property #>", Kind = <#=ef.IsKey(property)?"FieldKinds.PrimaryKey":(isVersion?"FieldKinds.Version":"FieldKinds.Primitive") #>,PropertyType =typeof(<#=
    code.Escape(property.TypeUsage)#>) ,Nullable=<#=
    property.Nullable.ToString().ToLower() #>,TargetType =null,
	IsIdentity=<#=isIdentity==null?"null":isIdentity.ToString().ToLower()#>
    <#
    if(property.TypeUsage!=null && property.TypeUsage.EdmType.Name=="String")
    {
    #>,Size=<#=size#>
	,Unicode=<#=
    property.TypeUsage.Facets["Unicode"].Value!=null?
	property.TypeUsage.Facets["Unicode"].Value.ToString().ToLower():
	"true"
    #>
	,FixedLength=<#=
    property.TypeUsage.Facets["FixedLength"].Value!=null?
	property.TypeUsage.Facets["FixedLength"].Value.ToString().ToLower():
	"false"
    #>
	,DefaultValue=<#=
    property.TypeUsage.Facets["DefaultValue"].Value!=null?
	property.TypeUsage.Facets["DefaultValue"].Value:
	"\"\""
    #>
    <#
    }
    #>

     };
      <#                
            }#>	
    }



private static IEnumerable<IField> GetNavigationFields()
{
<#       
            var  Properties= entity.NavigationProperties;
            if (Properties.Count()== 0)
            {#>
            return Enumerable.Empty<IField>();
             
<#            }
            foreach (NavigationProperty navProperty in Properties)
            {
            EdmProperty dpp=null;
			bool isCollection=navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many;
			if(navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many||
			navProperty.FromEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many){
			dpp= ef.GetDependentProperties(navProperty).FirstOrDefault();
			}
#>


            
        yield return new BaseField{Name= "<#=                    navProperty.Name#>", Kind = FieldKinds.Navigational,PropertyType =typeof(<#=isCollection?"Collection<"+code.Escape(navProperty.ToEndMember.GetEntityType())+">":code.Escape(navProperty.TypeUsage)#>),TargetType =typeof(<#=code.Escape(navProperty.ToEndMember.GetEntityType())   #>)
        ,DependentProperty="<#=dpp!=null ? dpp.ToString() : "" #>",
IsCollection=<#=  isCollection.ToString().ToLower() #>
,FromEndMultiplicity = Multiplicities.<#=                    navProperty.FromEndMember.RelationshipMultiplicity #>
,ToEndMultiplicity = Multiplicities.<#=                    navProperty.ToEndMember.RelationshipMultiplicity #>
        };
<#          
            }#>
}

public <#=impMethod#> Expression GetPrimaryKeyPrediacate()
{
    <#            string tempexp = "p => ";
            foreach (var  property in entity.Properties)
            {
                if(ef.IsKey(property))
                {
                    var typeStr =   code.Escape(property.TypeUsage);

                    var rightExpressionStr= string.Format("({0})this.GetValue(\"{1}\")",typeStr,property);
                #>var v<#=                        property#>=<#=                        rightExpressionStr#>;<#
                    var statement= string.Format("p.{0} == v{1} && ",property,property);

                    tempexp = tempexp + statement;
                }
            }
    #>

    Expression<Func<<#=                entity.Name #>,bool>> exp = <#=                tempexp.Trim().Substring(0,tempexp.Length -3)#>;
    return exp;        

}

public <#=impMethod#> object GetValue(string propertyName)
{
    object retVal = null;
    switch(propertyName.ToLower())
    {
    <#            foreach (var  property in entity.Properties)
            {#>
    case "<#=                    property.Name.ToLower()   #>":
            retVal = this.<#=                    property   #>;
            break;
    <#            }#>	
    <#            foreach (var  property in entity.NavigationProperties.Where(n => n.DeclaringType == entity))
            {#>
    case "<#=                    property.Name.ToLower()#>":
               retVal= this.<#=                    property   #>;
        break;
    <#            }#>
                default:
				<#if(entity.BaseType!=null){#>
            retVal = base.GetValue(propertyName);
			<#}else{#>
			retVal=null;
			<#}#>
            break;
    }
    return retVal;
}

		private Dictionary<string,object> __tags;
		public <#=impMethod#> void AddTag(string key, object value)
        {
            if(__tags==null)__tags=new Dictionary<string,object>();
			if(!__tags.ContainsKey(key)) __tags.Add(key,value);
        }  

		public <#=impMethod#> object GetTag(string key)
        {
            if(__tags==null)return null;
			if(!__tags.ContainsKey(key))return null;
			return __tags[key];
        }

        public <#=impMethod#> object RemoveTag(string key)
        {
            if (__tags == null) return null;
            if (__tags.ContainsKey(key)){
			var result= __tags[key];
                __tags.Remove(key);
				return result;
			}
			return  null;
        }
        public <#=impMethod#> bool HasKey()
        {
			<# var pkProperty= entity.Properties.Where(x=>ef.IsKey(x)).First(); #>

			return <#=code.FieldName(pkProperty)#>!=default(<#=code.Escape(pkProperty.TypeUsage)#>);
        }
  
 public <#=impMethod#> void StartTracking()
        {
		if(ChangeTracker.ChangeTrackingEnabled) return;
		<#if(entity.BaseType!=null){#>
            base.StartTracking();
			<#}#>
            ChangeTracker.ChangeTrackingEnabled = true;
            <#       
            foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(n => n.DeclaringType == entity))
            if(navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
            {
            #>
            for(int i=0;i<<#= navProperty.Name #>.Count;++i)
                ((IObjectWithChangeTracker)<#= navProperty.Name #>[i]).StartTracking();
                <#}else{#>
				if(<#= navProperty.Name #>!=null) <#= navProperty.Name #>.StartTracking();
                <#}#>
        }

        public <#=impMethod#> void StopTracking()
        {
		<#if(entity.BaseType!=null){#>
            base.StopTracking();
			<#}#>
         ChangeTracker.ChangeTrackingEnabled = false;
           <#       
            foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(n => n.DeclaringType == entity))
            if(navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
            {
            #>
            for(int i=0;i<<#= navProperty.Name #>.Count;++i)
                ((IObjectWithChangeTracker)<#= navProperty.Name #>[i]).StopTracking();
                <#}#>
        }

public <#=impMethod#> bool SetValue(string propertyName, object value)
{
    switch(propertyName.ToLower())
    {
<#            foreach (var  property in entity.Properties)
            {#>
        case "<#=                    property.Name.ToLower()  #>":
            this.<#=                    property   #> =(<#=                    code.Escape(property.TypeUsage)#>)value;
        break;
<#            }#>	
<#            foreach (var  property in entity.NavigationProperties.Where(n => n.DeclaringType == entity))
            {#>
        case "<#=                    property.Name.ToLower()   #>":
<#                if(property.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many )
                {#>         this.<#=                        property   #> =(TrackableCollection<<#=                        code.Escape( property.ToEndMember.GetEntityType())#>>) value;
<#                } else
                {#>         this.<#=                        property   #> =( <#=                        code.Escape( property.ToEndMember.GetEntityType())#>) value;
<#                }#>
        break;
<#            }#>
                default:
           <#if(entity.BaseType!=null){#>
             return base.SetValue(propertyName,value);
			<#}else{#>
                    return Exir.Framework.Common.Fasterflect.PropertyExtensions.TrySetPropertyValue(this, propertyName, value);
			<#}#>
            break;
   }   
   return true;
}
        <#
            region.End();

    region.Begin("ChangeTracking");
    if (entity.BaseType == null)
    {
#>

    protected virtual void OnPropertyChanged(String propertyName)
    {
        if (ChangeTracker.State != ObjectState.Added && ChangeTracker.State != ObjectState.Deleted)
        {
            ChangeTracker.State = ObjectState.Modified;
        }
        if (_propertyChanged != null)
        {
            _propertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    protected virtual void OnNavigationPropertyChanged(String propertyName)
    {
        if (_propertyChanged != null)
        {
            _propertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged{ add { _propertyChanged += value; } remove { _propertyChanged -= value; } }
    private event PropertyChangedEventHandler _propertyChanged;
 	[NonSerialized]

   private ObjectChangeTracker _changeTracker;
	  [NotMapped]

        [ProtoIgnore]

        [Newtonsoft.Json.JsonIgnore]

        [Jil.JilDirective(Ignore =true)]

    [System.Xml.Serialization.XmlIgnore]

    public <#=impMethod#> ObjectChangeTracker ChangeTracker
    {
        get
        {
            if (_changeTracker == null)
            {
                _changeTracker = new ObjectChangeTracker();
                _changeTracker.ObjectStateChanging += HandleObjectStateChanging;
                          _propertyChanged += new PropertyChangedEventHandler(delegate(object sender, PropertyChangedEventArgs e)
                    {
                    if(ChangeTracker.ChangeTrackingEnabled)
                        ChangeTracker.RecordPropertyChange(e.PropertyName);
                    });
      }
            return _changeTracker;
        }
        set
        {
            if(_changeTracker != null)
            {
                _changeTracker.ObjectStateChanging -= HandleObjectStateChanging;
            }
            _changeTracker = value;
            if(_changeTracker != null)
            {
                _changeTracker.ObjectStateChanging += HandleObjectStateChanging;
            }
        }
    }

       


    private void HandleObjectStateChanging(object sender, ObjectStateChangingEventArgs e)
    {
        if (e.NewState == ObjectState.Deleted)
        {
            ClearNavigationProperties();
        }
    }
	[NotMapped]

    protected bool IsDeserializing { get; private set; }

    [OnDeserializing]

    public void OnDeserializingMethod(StreamingContext context)
    {
        IsDeserializing = true;
    }

    [OnDeserialized]

    public void OnDeserializedMethod(StreamingContext context)
    {
        IsDeserializing = false;
        ChangeTracker.ChangeTrackingEnabled = true;
    }
<#
    }

    // If this entity type participates in any relationships where the other end has an OnDelete
    // cascade delete defined, or if it is the dependent in any identifying relationships, it needs
    // an event handler to handle notifications that are fired when the parent is deleted.
    if (ef.NeedsHandleCascadeDeleteMethod(ItemCollection, entity))
    {
#>

    // This entity type is the dependent end in at least one association that performs cascade deletes.
    // This event handler will process notifications that occur when the principal end is deleted.
    internal void HandleCascadeDelete(object sender, ObjectStateChangingEventArgs e)
    {
        if (e.NewState == ObjectState.Deleted)
        {
            this.MarkAsDeleted();
        }
    }
<#
    }

    foreach(EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entity))
    {
#>
    // <#=String.Format(CultureInfo.CurrentCulture, "Records the original values for the complex property {0}", edmProperty.Name)#>
    private void Handle<#=edmProperty.Name#>Changing(object sender, EventArgs args)
    {
        if (ChangeTracker.State != ObjectState.Added && ChangeTracker.State != ObjectState.Deleted)
        {
            ChangeTracker.State = ObjectState.Modified;
        }
<#
        if (originalValueMembers.IsOriginalValueMember(edmProperty))
        {
#>
        <#=code.Escape(edmProperty.TypeUsage)#>.RecordComplexOriginalValues("<#=edmProperty.Name#>", this.<#=code.Escape(edmProperty)#>, ChangeTracker);
<#
        }
#>
    }

<#
    }

    List<AssociationEndMember> shadowAssociationEnds = new List<AssociationEndMember>();
    foreach(var association in ItemCollection.GetItems<AssociationType>().Where(x => !IsForeignKeyOrIdentifyingRelationship(ef, x) &&
                                                                                ((((RefType)x.AssociationEndMembers[0].TypeUsage.EdmType).ElementType == entity &&
                                                                                   x.AssociationEndMembers[0].RelationshipMultiplicity != RelationshipMultiplicity.One &&
                                                                                   x.AssociationEndMembers[1].RelationshipMultiplicity != RelationshipMultiplicity.Many) ||
                                                                                 ((RefType)x.AssociationEndMembers[1].TypeUsage.EdmType).ElementType == entity &&
                                                                                   x.AssociationEndMembers[1].RelationshipMultiplicity != RelationshipMultiplicity.One &&
                                                                                   x.AssociationEndMembers[0].RelationshipMultiplicity != RelationshipMultiplicity.Many)))
    {
        if (!entity.NavigationProperties.Any(x => x.RelationshipType == association && IsReadWriteAccessibleProperty(x)))
        {
            for (int i = 0; i < 2; i++)
            {
                int targetRoleIndex = 0;
                if (((RefType)association.AssociationEndMembers[i].TypeUsage.EdmType).ElementType == entity)
                {
                    targetRoleIndex = (i + 1) % 2;
                    shadowAssociationEnds.Add(association.AssociationEndMembers[targetRoleIndex]);
                }
            }
        }
    }
#>

    protected <#=entity.BaseType == null ? "virtual " : "override " #>void ClearNavigationProperties()
    {
<#
    if (entity.BaseType != null)
    {
#>
        base.ClearNavigationProperties();
<#
    }
    foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(np => np.DeclaringType == entity))
    {
        if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
#>
        <#=code.Escape(navProperty)#>.Clear();
<#
        }
        else
        {
#>
        <#=code.Escape(navProperty)#> = null;
<#
            if (IsSaveReference(ef, navProperty))
            {
#>
        Fixup<#=navProperty.Name#>Keys();
<#
            }
        }
    }
    foreach(var associationEnd in shadowAssociationEnds)
    {
        AssociationType association = associationEnd.DeclaringType as AssociationType;
#>
        <#=CreateFixupMethodName(associationEnd)#>(null, true);
<#
    }
#>
    }
<#
    region.End();

    region.Begin("Association Fixup");

    foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(np => np.DeclaringType == entity))
    {
        NavigationProperty inverse = ef.Inverse(navProperty);

        if (inverse != null && !IsReadWriteAccessibleProperty(inverse))
        {
            inverse = null;
        }

        if (navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
        {
            var skipKeysArgument = navProperty.GetDependentProperties().Where(p=>ef.IsNullable(p)).Any()
                ? ", bool skipKeys = false"
                : String.Empty;
#>

    private void Fixup<#=navProperty.Name#>(<#=code.Escape(navProperty.ToEndMember.GetEntityType())#> previousValue<#= skipKeysArgument #>)
    {
<#
        if (ef.IsCascadeDeletePrincipal(navProperty))
        {
#>
        // This is the principal end in an association that performs cascade deletes.
        // Update the event listener to refer to the new dependent.
        if (previousValue != null)
        {
            ChangeTracker.ObjectStateChanging -= previousValue.HandleCascadeDelete;
        }

        if (<#=code.Escape(navProperty)#> != null)
        {
            ChangeTracker.ObjectStateChanging += <#=code.Escape(navProperty)#>.HandleCascadeDelete;
        }

<#
        }
        else if (inverse == null && ef.IsCascadeDeletePrincipal((AssociationEndMember)navProperty.ToEndMember))
        {
#>
        // This is the dependent end in an association that performs cascade deletes.
        // Update the principal's event listener to refer to the new dependent.
        // This is a unidirectional relationship from the dependent to the principal, so the dependent end is
        // responsible for managing the cascade delete event handler. In all other cases the principal end will manage it.
        if (previousValue != null)
        {
            previousValue.ChangeTracker.ObjectStateChanging -= HandleCascadeDelete;
        }

        if (<#=code.Escape(navProperty)#> != null)
        {
            <#=code.Escape(navProperty)#>.ChangeTracker.ObjectStateChanging += HandleCascadeDelete;
        }

<#
        }
#>
        if (IsDeserializing)
        {
            return;
        }

<#
        if (inverse != null)
        {
            if (inverse.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
            {
#>
        if (previousValue != null && previousValue.<#=code.Escape(inverse)#>.Contains(this))
        {
            previousValue.<#=code.Escape(inverse)#>.Remove(this);
        }
<#
            }
            else
            {
#>
        if (previousValue != null && ReferenceEquals(previousValue.<#=code.Escape(inverse)#>, this))
        {
            previousValue.<#=code.Escape(inverse)#> = null;
        }
<#
            }

            if (inverse.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
            {
#>

        if (<#=code.Escape(navProperty)#> != null)
        {
            if (!<#=code.Escape(navProperty)#>.<#=code.Escape(inverse)#>.Contains(this))
            {
                <#=code.Escape(navProperty)#>.<#=code.Escape(inverse)#>.Add(this);
            }

<#
                foreach (var dependentProperty in navProperty.GetDependentProperties())
                {
#>
            <#=code.Escape(dependentProperty)#> = <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>;
<#
                }
#>
        }
<#
                if (navProperty.GetDependentProperties().Where(p=>ef.IsNullable(p)).Any())
                {
#>
        else if (!skipKeys)
        {
<#
                foreach (var dependentProperty in navProperty.GetDependentProperties().Where(p => ef.IsNullable(p)))
                {
#>
            <#=code.Escape(dependentProperty)#> = null;
<#
                }
#>
        }

<#
                }
            }
            else
            {
#>

        if (<#=code.Escape(navProperty)#> != null)
        {
            <#=code.Escape(navProperty)#>.<#=code.Escape(inverse)#> = this;
<#
                foreach (var dependentProperty in navProperty.GetDependentProperties())
                {
#>
            <#=code.Escape(dependentProperty)#> = <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>;
<#
                }
#>
        }

<#
            }
        }
        else
        {
            if (navProperty.GetDependentProperties().Any())
            {
#>
        if (<#=code.Escape(navProperty)#> != null)
        {
<#
                foreach (var dependentProperty in navProperty.GetDependentProperties())
                {
#>
            <#=code.Escape(dependentProperty)#> = <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingPrincipalProperty(navProperty, dependentProperty))#>;
<#
                }
#>
        }

<#
                if (navProperty.GetDependentProperties().Where(p => ef.IsNullable(p)).Any())
                {
#>
        else if (!skipKeys)
        {
<#
                    foreach (var dependentProperty in navProperty.GetDependentProperties().Where(p => ef.IsNullable(p)))
                    {
#>
            <#=code.Escape(dependentProperty)#> = null;
<#
                    }
#>
        }

<#
                }
            }
            else if (IsForeignKeyOrIdentifyingRelationship(ef, navProperty))
            {
#>
        if (<#=code.Escape(navProperty)#> != null)
        {
<#
                foreach (var fromProperty in ef.GetPrincipalProperties(navProperty))
                {
#>
            <#=code.Escape(navProperty)#>.<#=code.Escape(ef.GetCorrespondingDependentProperty(navProperty, fromProperty))#> = <#=code.Escape(fromProperty)#>;
<#
                }
#>
        }

<#
            }
        }
#>
        if (ChangeTracker.ChangeTrackingEnabled)
        {
            if (ChangeTracker.OriginalValues.ContainsKey("<#=navProperty.Name#>")
                && (ChangeTracker.OriginalValues["<#=navProperty.Name#>"] == <#=code.Escape(navProperty)#>))
            {
                ChangeTracker.OriginalValues.Remove("<#=navProperty.Name#>");
            }
            else
            {
                ChangeTracker.RecordOriginalValue("<#=navProperty.Name#>", previousValue);
<#
        if (ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.FromEndMember))
        {
#>
                // This is the principal end of an identifying association, so the dependent must be deleted when the relationship is removed.
                // If the current state of the dependent is Added, the relationship can be changed without causing the dependent to be deleted.
                if (previousValue != null && previousValue.ChangeTracker.State != ObjectState.Added)
                {
                    previousValue.MarkAsDeleted();
                }
<#
        }
        else if (inverse == null && ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.ToEndMember))
        {
#>
                // This is the dependent end of an identifying association, so it must be deleted when the relationship is
                // removed. If the current state is Added, the relationship can be changed without causing the dependent to be deleted.
                // This is a unidirectional relationship from the dependent to the principal, so the dependent end is
                // responsible for cascading the delete. In all other cases the principal end will manage it.
                if (previousValue != null && ChangeTracker.State != ObjectState.Added)
                {
                    this.MarkAsDeleted();
                }
<#
        }
#>
            }
            if (<#=code.Escape(navProperty)#> != null && !<#=code.Escape(navProperty)#>.ChangeTracker.ChangeTrackingEnabled)
            {
                <#=code.Escape(navProperty)#>.StartTracking();
            }
<#
        if (IsSaveReference(ef, navProperty))
        {
#>
            Fixup<#=navProperty.Name#>Keys();
<#
        }
        if (inverse == null &&
            !IsForeignKeyOrIdentifyingRelationship(ef, navProperty) &&
            navProperty.FromEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many &&
            navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.One)
        {
#>
            if (previousValue != null)
            {
                previousValue.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(null, false);
            }
            if (<#=code.Escape(navProperty)#> != null)
            {
                <#=code.Escape(navProperty)#>.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(this, false);
            }
<#
        }
#>
        }
    }
<#
        if (IsSaveReference(ef, navProperty))
        {
            EntityType targetType = (EntityType)navProperty.TypeUsage.EdmType;
            List<string> keyNames = targetType.KeyMembers.Select(x => x.Name).ToList();
#>

    private void Fixup<#=navProperty.Name#>Keys()
    {
<#
            for(int k=0; k < keyNames.Count; k++)
            {
#>
        const string <#=CreateKeyNameVariable(code.Escape(keyNames[k]))#> = "<#=CreateReferenceValueLookupKey(navProperty, keyNames[k])#>";
<#
            }
#>

        if(ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames[0]))#>)<#=keyNames.Count > 1 ? " &&" : ")"#>
<#
            for(int k=1; k < keyNames.Count; k++)
            {
#>
           ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>)<#=k < keyNames.Count - 1 ? " &&" : ")" #>
<#
            }
#>
        {
            if(<#=code.Escape(navProperty)#> == null ||
<#
            for(int k=0; k < keyNames.Count; k++)
            {
                string equality =targetType.KeyMembers[keyNames[k]].TypeUsage.EdmType is PrimitiveType && ((PrimitiveType)targetType.KeyMembers[keyNames[k]].TypeUsage.EdmType).PrimitiveTypeKind == PrimitiveTypeKind.Binary ? "EqualityComparer.Binary" : String.Empty;
#>
               !<#=equality#>Equals(ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>], <#=code.Escape(navProperty)#>.<#=code.Escape(keyNames[k])#>)<#=k < keyNames.Count - 1 ? " ||" : ")" #>
<#
            }
#>
            {
<#
            for(int k=0; k < keyNames.Count; k++)
            {
#>
                ChangeTracker.RecordOriginalValue(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>, ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>]);
<#
            }
#>
            }
<#
            for(int k=0; k < keyNames.Count; k++)
            {
#>
            ChangeTracker.ExtendedProperties.Remove(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>);
<#
            }
#>
        }
    }
<#
            }
        }
    }

    foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(np => np.DeclaringType == entity))
    {
        NavigationProperty inverse = ef.Inverse(navProperty);

        if (inverse != null && !IsReadWriteAccessibleProperty(inverse))
        {
            inverse = null;
        }

        if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
#>

    private void Fixup<#=navProperty.Name#>(object sender, NotifyCollectionChangedEventArgs e)
    {
        if (IsDeserializing)
        {
            return;
        }

        if (e.NewItems != null)
        {
            foreach (<#=code.Escape(navProperty.ToEndMember.GetEntityType())#> item in e.NewItems)
            {
<#
                if (inverse != null)
                {
                    if (inverse.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
                    {
#>
                item.<#=code.Escape(inverse)#> = this;
<#
                    }
                    else
                    {
#>
                if (!item.<#=code.Escape(inverse)#>.Contains(this))
                {
                    item.<#=code.Escape(inverse)#>.Add(this);
                }
<#
                    }
                }
                else if (IsForeignKeyOrIdentifyingRelationship(ef, navProperty))
                {
                    foreach (var fromProperty in ef.GetPrincipalProperties(navProperty))
                    {
#>
                item.<#=code.Escape(ef.GetCorrespondingDependentProperty(navProperty, fromProperty))#> = <#=code.Escape(fromProperty)#>;
<#
                    }
                }
                else if (navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne)
                {
#>
                item.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(this, false);
<#
                }
#>
                if (ChangeTracker.ChangeTrackingEnabled)
                {
                    if (!item.ChangeTracker.ChangeTrackingEnabled)
                    {
                        item.StartTracking();
                    }
                    ChangeTracker.RecordAdditionToCollectionProperties("<#=code.Escape(navProperty)#>", item);
                }
<#
                if (ef.IsCascadeDeletePrincipal(navProperty))
                {
#>
                // This is the principal end in an association that performs cascade deletes.
                // Update the event listener to refer to the new dependent.
                ChangeTracker.ObjectStateChanging += item.HandleCascadeDelete;
<#
                }
#>
            }
        }

        if (e.OldItems != null)
        {
            foreach (<#=code.Escape(navProperty.ToEndMember.GetEntityType())#> item in e.OldItems)
            {
<#
                if (inverse != null)
                {
                    if (inverse.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
                    {
#>
                if (ReferenceEquals(item.<#=code.Escape(inverse)#>, this))
                {
                    item.<#=code.Escape(inverse)#> = null;
                }
<#
                    }
                    else
                    {
#>
                if (item.<#=code.Escape(inverse)#>.Contains(this))
                {
                    item.<#=code.Escape(inverse)#>.Remove(this);
                }
<#
                    }
                }
                else if (IsForeignKeyOrIdentifyingRelationship(ef, navProperty))
                {
                    foreach (var fromProperty in ef.GetPrincipalProperties(navProperty))
                    {
                        var p = ef.GetCorrespondingDependentProperty(navProperty, fromProperty);
                        if (ef.IsNullable(p.TypeUsage))
                        {
#>
                item.<#=code.Escape(p)#> = null;
<#
                        }
                    }
                }
                else if (navProperty.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne)
                {
#>
                item.<#=CreateFixupMethodName(navProperty.FromEndMember)#>(null, false);
<#
                }
#>
                if (ChangeTracker.ChangeTrackingEnabled)
                {
                    ChangeTracker.RecordRemovalFromCollectionProperties("<#=code.Escape(navProperty)#>", item);
<#
                if (ef.IsPrincipalEndOfIdentifyingRelationship((AssociationEndMember)navProperty.FromEndMember))
                {
#>
                    // Delete the dependent end of this identifying association. If the current state is Added,
                    // allow the relationship to be changed without causing the dependent to be deleted.
                    if (item.ChangeTracker.State != ObjectState.Added)
                    {
                        item.MarkAsDeleted();
                    }
<#
                }
#>
                }
<#
                if (ef.IsCascadeDeletePrincipal(navProperty))
                {
#>
                // This is the principal end in an association that performs cascade deletes.
                // Remove the previous dependent from the event listener.
                ChangeTracker.ObjectStateChanging -= item.HandleCascadeDelete;
<#
                }
#>
            }
        }
    }
<#
        }
    }

    foreach(var associationEnd in shadowAssociationEnds)
    {
        AssociationType association = associationEnd.DeclaringType as AssociationType;
        EntityType targetType = ((RefType)associationEnd.TypeUsage.EdmType).ElementType as EntityType;
        List<string> keyNames = targetType.KeyMembers.Select(x => x.Name).ToList();
#>

    internal void <#=CreateFixupMethodName(associationEnd)#>(<#=code.Escape(targetType)#> value, bool forceRemove)
    {
<#
            for(int k=0; k < keyNames.Count; k++)
            {
#>
        const string <#=CreateKeyNameVariable(code.Escape(keyNames[k]))#> = "<#=CreateReferenceValueLookupKey(associationEnd, keyNames[k])#>";
<#
            }
#>

        if (ChangeTracker.ChangeTrackingEnabled &&
<#
        for(int k=0; k < keyNames.Count; k++)
        {
#>
            ChangeTracker.ExtendedProperties.ContainsKey(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>)<#=k < keyNames.Count - 1 ? " &&" : ")"#>
<#
        }
#>
        {
            if (forceRemove ||
<#
        for(int k=0; k < keyNames.Count; k++)
        {
                string equality =targetType.KeyMembers[keyNames[k]].TypeUsage.EdmType is PrimitiveType && ((PrimitiveType)targetType.KeyMembers[keyNames[k]].TypeUsage.EdmType).PrimitiveTypeKind == PrimitiveTypeKind.Binary ? "EqualityComparer.Binary" : String.Empty;
#>
                !<#=equality#>Equals(ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>], value == null ? null : (object)value.<#=code.Escape(keyNames[k])#>)<#=k < keyNames.Count - 1 ? " ||" : ")"#>
<#
        }
#>
            {
<#
        for(int k=0; k < keyNames.Count; k++)
        {
#>
                ChangeTracker.RecordOriginalValue(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>, ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>]);
<#
        }
#>
                if (value == null)
                {
<#
        for(int k=0; k < keyNames.Count; k++)
        {
#>
                    ChangeTracker.ExtendedProperties.Remove(<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>);
<#
        }
#>
                }
                else
                {
<#
        for(int k=0; k < keyNames.Count; k++)
        {
#>
                    ChangeTracker.ExtendedProperties[<#=CreateKeyNameVariable(code.Escape(keyNames[k]))#>] = value.<#=code.Escape(keyNames[k])#>;
<#
        }
#>
                }
            }
        }
    }
<#
    }

    region.End();
#>
}
<#
    EndNamespace(namespaceName);
}

foreach (ComplexType complex in ItemCollection.GetItems<ComplexType>().OrderBy(e => e.Name))
{
    fileManager.StartNewFile(complex.Name + ".cs");
    BeginNamespace(namespaceName, code);
	int protoMemberIndex=1;
#>
[ProtoContract]

<#=Accessibility.ForType(complex)#> partial class <#=code.Escape(complex)#> : INotifyComplexPropertyChanging, INotifyPropertyChanged
{
<#
    region.Begin("Primitive Properties");

    foreach(EdmProperty edmProperty in complex.Properties.Where(p => p.TypeUsage.EdmType is SimpleType && p.DeclaringType == complex))
    {
#>

  	[ProtoMember(<#=protoMemberIndex++#>)]

  [DataMember]

    <#=Accessibility.ForProperty(edmProperty)#> <#=code.Escape(edmProperty.TypeUsage)#> <#=code.Escape(edmProperty)#>
    {
        <#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get { return <#=code.FieldName(edmProperty)#>; }
        <#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set
        {
            if (<#=code.FieldName(edmProperty)#> != value)
            {
                OnComplexPropertyChanging();
                <#=code.FieldName(edmProperty)#> = value;
                OnPropertyChanged("<#=edmProperty.Name#>");
            }
        }
    }
    private <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#><#=code.StringBefore(" = ", code.CreateLiteral(edmProperty.DefaultValue))#>;
<#
    }

    region.End();

    region.Begin("Complex Properties");

    foreach(EdmProperty edmProperty in complex.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == complex))
    {
#>

    [ProtoMember(<#=protoMemberIndex++#>)]

	[DataMember]

    <#=Accessibility.ForProperty(edmProperty)#> <#=code.Escape(edmProperty.TypeUsage)#> <#=code.Escape(edmProperty)#>
    {
        <#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get
        {
            if (!<#=InitializedTrackingField(edmProperty, code)#> && <#=code.FieldName(edmProperty)#> == null)
            {
                <#=code.FieldName(edmProperty)#> = new <#=code.Escape(edmProperty.TypeUsage)#>();
                ((INotifyComplexPropertyChanging)<#=code.FieldName(edmProperty)#>).ComplexPropertyChanging += HandleComplexPropertyChanging;
            }
            <#=InitializedTrackingField(edmProperty, code)#> = true;
            return <#=code.FieldName(edmProperty)#>;
        }
        <#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set
        {
            <#=InitializedTrackingField(edmProperty, code)#> = true;
            if (!Equals(<#=code.FieldName(edmProperty)#>, value))
            {
                if (<#=code.FieldName(edmProperty)#> != null)
                {
                    ((INotifyComplexPropertyChanging)<#=code.FieldName(edmProperty)#>).ComplexPropertyChanging -= HandleComplexPropertyChanging;
                }

                OnComplexPropertyChanging();
                <#=code.FieldName(edmProperty)#> = value;
                OnPropertyChanged("<#=edmProperty.Name#>");

                if (value != null)
                {
                    ((INotifyComplexPropertyChanging)value).ComplexPropertyChanging += HandleComplexPropertyChanging;
                }
            }
        }
    }
    private <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#>;
    private bool <#=InitializedTrackingField(edmProperty, code)#>;
<#
    }

    region.End();

    region.Begin("ChangeTracking");
#>

    private void OnComplexPropertyChanging()
    {
        if (_complexPropertyChanging != null)
        {
            _complexPropertyChanging(this, new EventArgs());
        }
    }

    event EventHandler INotifyComplexPropertyChanging.ComplexPropertyChanging { add { _complexPropertyChanging += value; } remove { _complexPropertyChanging -= value; } }
    private event EventHandler _complexPropertyChanging;

    private void OnPropertyChanged(String propertyName)
    {
        if (_propertyChanged != null)
        {
            _propertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged { add { _propertyChanged += value; } remove { _propertyChanged -= value; } }
    private event PropertyChangedEventHandler _propertyChanged;
<#
    if(complex.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == complex).Count() > 0)
    {
#>

    private void HandleComplexPropertyChanging(object sender, EventArgs args)
    {
        // Bubble the event to all listeners because something changed in a nested complex property
        OnComplexPropertyChanging();
    }
<#
    }
#>

    public static void RecordComplexOriginalValues(String parentPropertyName, <#=code.Escape(complex)#> complexObject, ObjectChangeTracker changeTracker)
    {
        if (String.IsNullOrEmpty(parentPropertyName))
        {
            throw new ArgumentException("String parameter cannot be null or empty.", "parentPropertyName");
        }

        if (changeTracker == null)
        {
            throw new ArgumentNullException("changeTracker");
        }
<#
        foreach(EdmProperty complexProperty in complex.Properties)
        {
            if (complexProperty.TypeUsage.EdmType is ComplexType)
            {
#>
        <#=code.Escape(complexProperty.TypeUsage)#>.RecordComplexOriginalValues(String.Format(CultureInfo.InvariantCulture, "{0}.<#=complexProperty.Name#>", parentPropertyName), complexObject == null ? null : complexObject.<#=code.Escape(complexProperty)#>, changeTracker);
<#
            }
            else
            {
#>
        changeTracker.RecordOriginalValue(String.Format(CultureInfo.InvariantCulture, "{0}.<#=complexProperty.Name#>", parentPropertyName), complexObject == null ? null : (object)complexObject.<#=code.Escape(complexProperty)#>);
<#
            }
        }
#>
    }
<#
    region.End();
#>
}
<#
    EndNamespace(namespaceName);
}

if (!VerifyTypesAreCaseInsensitiveUnique(ItemCollection))
{
    return "";
}

fileManager.Process();

#>
<#+
void WriteHeader(EntityFrameworkTemplateFileManager fileManager, params string[] extraUsings)
{
    fileManager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Globalization;
using System.Runtime.Serialization;
using Exir.Framework.Common;
using System.Linq.Expressions;
using System.Linq;
using ProtoBuf;
using System.ComponentModel.DataAnnotations.Schema;
using Exir.Framework.Common.Serialization;
using System.ComponentModel.DataAnnotations;
<#=String.Join(String.Empty, extraUsings.Select(u => "using " + u + ";" + Environment.NewLine).ToArray())#>
<#+
    fileManager.EndBlock();
}

void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}

void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}

bool IsReadWriteAccessibleProperty(EdmMember member)
{
    string setter = Accessibility.ForWriteOnlyProperty(member);
    string getter = Accessibility.ForReadOnlyProperty(member);

    return getter != "private" && getter != "protected" && setter != "private" && setter != "protected";
}

string InitializedTrackingField(EdmProperty property, CodeGenerationTools code)
{
    string namePart = property.Name + "Initialized";
    if (code.CamelCaseFields)
    {
        namePart = code.CamelCase(namePart);
    }
    return "_" + namePart;
}

void WriteEntityTypeSerializationInfo(EntityType type, ItemCollection itemCollection, CodeGenerationTools code, MetadataTools tools)
{
#>
[Serializable]

[DataContract(IsReference = true)]

<#+
int protoIndex=0;
    foreach(EntityType subtype in tools.GetSubtypesOf(type, itemCollection, true))
    {
	protoIndex+=100;
#>
 [ProtoInclude(<#=protoIndex#>,typeof(<#=code.Escape(subtype)#>))]

[KnownType(typeof(<#=code.Escape(subtype)#>))]

<#+
    }
    List<EntityType> knownNavPropertyTypes = new List<EntityType>();
    foreach(NavigationProperty navProperty in type.NavigationProperties.Where(np => np.DeclaringType == type))
    {
        EntityType navPropertyType = navProperty.ToEndMember.GetEntityType();
        if(!knownNavPropertyTypes.Contains(navPropertyType))
        {
            knownNavPropertyTypes.Add(navPropertyType);
        }
    }
    foreach(EntityType knownNavPropertyType in knownNavPropertyTypes)
    {
#>
[KnownType(typeof(<#=code.Escape(knownNavPropertyType)#>))]

<#+
    }
}

bool IsSaveReference(MetadataTools tools, NavigationProperty navProperty)
{
    return !IsForeignKeyOrIdentifyingRelationship(tools, navProperty) &&
           navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many &&         // Target is a reference
           navProperty.FromEndMember.RelationshipMultiplicity != RelationshipMultiplicity.One;          // Source is nullable (i.e. not a PK)
}

string CreateFixupMethodName(RelationshipEndMember endMember)
{
    return String.Format(CultureInfo.InvariantCulture, "Fixup{0}_{1}_{2}Keys", endMember.DeclaringType.NamespaceName.Replace(".", "_"), endMember.DeclaringType.Name, endMember.Name);
}

string CreateKeyNameVariable(string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "{0}KeyName", keyName);
}

string CreateReferenceValueLookupKey(AssociationEndMember endMember, string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "Navigate({0}.{1}).{2}", endMember.DeclaringType.FullName, endMember.Name, keyName);
}

string CreateReferenceValueLookupKey(NavigationProperty navProp, string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "{0}.{1}", navProp.Name, keyName);
}

void WriteCustomObservableCollection()
{
#>




<#+
}


void WriteINotifyComplexPropertyChanging()
{
#>

<#+
}

void WriteEqualityComparer()
{
#>






<#+
}

bool VerifyTypesAreCaseInsensitiveUnique(EdmItemCollection itemCollection)
{
    Dictionary<string, bool> alreadySeen = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
    foreach(StructuralType type in itemCollection.GetItems<StructuralType>())
    {
        if (!(type is EntityType || type is ComplexType))
        {
            continue;
        }

        if (alreadySeen.ContainsKey(type.FullName))
        {
            Error(String.Format(CultureInfo.CurrentCulture, "This template does not support types that differ only by case, the types {0} are not supported", type.FullName));
            return false;
        }
        else
        {
            alreadySeen.Add(type.FullName, true);
        }

    }

    return true;
}

// True if the association for the specified navigation property is an identifying relationship or a foreign key relationship.
private bool IsForeignKeyOrIdentifyingRelationship(MetadataTools tools, NavigationProperty navProperty)
{
    if (tools == null)
    {
        throw new ArgumentNullException("tools");
    }

    if (navProperty == null)
    {
        throw new ArgumentNullException("navProperty");
    }

    return IsForeignKeyOrIdentifyingRelationship(tools, (AssociationType)navProperty.RelationshipType);
}

// True if the specified association is an identifying relationship or a foreign key relationship.
private bool IsForeignKeyOrIdentifyingRelationship(MetadataTools tools, AssociationType association)
{
    if (tools == null)
    {
        throw new ArgumentNullException("tools");
    }

    if (association == null)
    {
        throw new ArgumentNullException("association");
    }

    return association.IsForeignKey || tools.IsIdentifyingRelationship(association);
}

// Set recordRequiredOriginalValuesOnly to false in the OriginalValueMembers constructor in order to always record all original values
public class OriginalValueMembers
{
    private readonly HashSet<EdmProperty> _concurrencyMembers;

    public OriginalValueMembers(bool recordRequiredOriginalValuesOnly, MetadataWorkspace metadataWorkspace, MetadataTools metadataTools)
    {
        if (recordRequiredOriginalValuesOnly)
        {
            try
            {
                _concurrencyMembers = new HashSet<EdmProperty>();
                foreach (EntityContainer container in metadataWorkspace.GetItems<EntityContainer>(DataSpace.CSpace))
                {
                    ILookup<EntityType, EntityType> directSubTypeLookup = metadataWorkspace.GetItems<EntityType>(DataSpace.CSpace).ToLookup(e => (EntityType)e.BaseType);
                    foreach (EntitySetBase eSet in container.BaseEntitySets.Where(es => es.BuiltInTypeKind == BuiltInTypeKind.EntitySet))
                    {
                        List<EntityType> subTypes = new List<EntityType>();
                        GetSubtypes(directSubTypeLookup, (EntityType)eSet.ElementType, subTypes);
                        foreach (EntityType eType in subTypes)
                        {
                            foreach (EdmProperty member in metadataWorkspace.GetRequiredOriginalValueMembers(eSet, eType))
                            {
                                _concurrencyMembers.Add(member);
                            }
                        }
                    }
                }

                // GetRequiredOriginalValueMembers will not always return foreign key properties, but they are required
                foreach (AssociationType assoc in metadataWorkspace.GetItems<AssociationType>(DataSpace.CSpace).Where(a => a.IsForeignKey))
                {
                    foreach (EdmProperty toProperty in assoc.ReferentialConstraints[0].ToProperties)
                    {
                        _concurrencyMembers.Add(toProperty);
                    }
                }
            }
            catch (Exception)
            {
                // If any exceptions occur, fall back to always recording original values for all properties
                _concurrencyMembers = null;
            }
        }
    }

    public bool IsOriginalValueMember(EdmProperty edmProperty)
    {
        return _concurrencyMembers == null || _concurrencyMembers.Contains(edmProperty);
    }

    private static void GetSubtypes(ILookup<EntityType, EntityType> lookup, EntityType eType, List<EntityType> subTypes)
    {
        subTypes.Add(eType);
        foreach (EntityType subType in lookup[eType])
        {
            GetSubtypes(lookup, subType, subTypes);
        }
    }
}
#>
